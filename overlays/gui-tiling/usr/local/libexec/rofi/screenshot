#!/bin/bash

set -e

## USER PREFERENCES ##
MENU="rofi -dmenu -i -l 10"
RECORDER=wf-recorder
TARGET=$(xdg-user-dir PICTURES)/screenshots
TARGET_VIDEOS=$(xdg-user-dir VIDEOS)/recordings

FOCUSED=$(swaymsg -t get_tree | jq '.. | ((.nodes? + .floating_nodes?) // empty) | .[] | select(.focused and .pid) | .rect | "\(.x),\(.y) \(.width)x\(.height)"')
OUTPUTS=$(swaymsg -t get_outputs | jq -r '.[] | select(.active) | .rect | "\(.x),\(.y) \(.width)x\(.height)"')
WINDOWS=$(swaymsg -t get_tree | jq -r '.. | select(.pid? and .visible?) | .rect | "\(.x),\(.y) \(.width)x\(.height)"')

NOTIFY=$(pidof mako || pidof dunst) || true
REC_PID=$(pidof $RECORDER) || true

mkdir -p "$TARGET"
mkdir -p "$TARGET_VIDEOS"
FILENAME="$TARGET/$(date +'screenshot-%Y-%m-%d_%H:%M:%S.png')"
RECORDING="$TARGET_VIDEOS/$(date +'recording-%Y-%m-%d_%H:%M:%S.mp4')"
RECORDER_OPTS=(-c h264_vaapi -d /dev/dri/renderD128 -f "$RECORDING")

notify() {
	## if the daemon is not running notify-send will hang indefinitely
	if [ "$NOTIFY" ]; then
		notify-send "$@"
	else
		echo NOTICE: notification daemon not active
		echo "$@"
	fi
}

if [ -n "$REC_PID" ]; then
	echo "pid: $REC_PID"
	kill -SIGINT "$REC_PID"
	notify "Screen recorder stopped" -t 2000
	exit 0
fi

## Check for specific type on args
case "$1" in
Fullscreen)
	CHOICE=$1
	;;
Region)
	CHOICE=$1
	;;
Select-output)
	CHOICE=$1
	;;
Select-window)
	CHOICE=$1
	;;
Focused)
	CHOICE=$1
	;;
Record-select-output)
	CHOICE=$1
	;;
Record-select-window)
	CHOICE=$1
	;;
Record-region)
	CHOICE=$1
	;;
Record-focused)
	CHOICE=$1
	;;
-h | --help)
	prog="$(basename "$(realpath "$0")")"
	cat <<ENDOFHELP
$prog - a script for controlling screenshots
usage: $prog [COMMAND]|[-h|--help]

COMMANDS
    Fullscreen              Capture the entire visible display from all outputs
    Region                  Draw a region to capture from
    Select-output           Select an output to capture
    Select-window           Select a window to capture
    Focused                 Capture the currently focused window
    Record-select-output    Select an output to capture video from
    Record-select-window    Select a window to capture video from
    Record-region           Draw a region to capture video from
    Record-focused          Capture video from the currently focused window

OPTIONS
    -h | --help             Print this help text and exit
ENDOFHELP
	exit 0
	;;
*)
	CHOICE=$(
		$MENU -u 5,6,7,8 -p "Enter a screenshot type" <<EOF
Fullscreen
Focused
Select-window
Select-output
Region
Record-focused
Record-select-window
Record-select-output
Record-region
EOF
	)
	;;
esac

function clean_up_audio {
	for ((i = ${#audio_modules_to_unload[@]} - 1; i >= 0; i--)); do
		pactl unload-module "${audio_modules_to_unload[$i]}"
	done
}
function record_audio {
	declare -A sources
	while read -r line; do
		if [ -n "$source_name" ]; then
			sources["$line"]="$source_name"
			unset source_name
		else
			source_name="$line"
		fi
	done < <(pactl list sources | awk '/(Name|Description):/{print}' | cut -d' ' -f2-)
	readarray -t audio_choices < <(
		$MENU -p "Select the audio devices to record with Tab" \
			-multi-select -kb-accept-alt "Tab" -kb-element-next "" \
			-no-custom -theme-str 'element-text { font: "Monospace 8"; }' < <(for source in "${!sources[@]}"; do echo "$source"; done)
	)
	audio_modules_to_unload=()
	trap clean_up_audio EXIT
	if ((${#audio_choices[@]} == 1)); then
		RECORDER_OPTS+=(-a${sources[${audio_choices[0]}]})
	elif ((${#audio_choices[@]} > 1)); then
		audio_modules_to_unload+=($(pactl load-module module-null-sink sink_name=Combined))
		for source_desc in "${audio_choices[@]}"; do
			source="${sources[$source_desc]}"
			echo "Adding $source to the Combined sink..."
			audio_modules_to_unload+=($(pactl load-module module-loopback sink=Combined source="$source"))
		done
		RECORDER_OPTS+=(-aCombined.monitor)
	fi
}

function record {
	record_audio
	set -x
	REC=true
	"$RECORDER" "${RECORDER_OPTS[@]}" -g "${@}"
	set +x
}

REC=false
## React to the choice
case "$CHOICE" in
Fullscreen)
	grim "$FILENAME"
	;;
Region)
	slurp | grim -g - "$FILENAME"
	;;
Select-output)
	echo "$OUTPUTS" | slurp | grim -g - "$FILENAME"
	;;
Select-window)
	echo "$WINDOWS" | slurp | grim -g - "$FILENAME"
	;;
Focused)
	grim -g "$(eval echo "$FOCUSED")" "$FILENAME"
	;;
Record-select-output)
	record "$(echo "$OUTPUTS" | slurp)"
	;;
Record-select-window)
	record "$(echo "$WINDOWS" | slurp)"
	;;
Record-region)
	record "$(slurp)"
	;;
Record-focused)
	record "$(eval echo "$FOCUSED")"
	;;
*)
	grim -g "$(eval echo "$CHOICE")" "$FILENAME"
	;;
esac

if $REC; then
	notify "Recording" "Recording stopped: $RECORDING" -t 10000
else
	notify "Screenshot" "File saved as $FILENAME\nand copied to clipboard" -t 6000 -i "$FILENAME"
	wl-copy <"$FILENAME"
fi
